# 분할 정복
주어진 문제를 둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산
> 문제를 한 조각과 나머지 전체로 나누는 재귀 호출과 달리 거의 같은 크기의 부분 문제로 나눈다.
## 분할 정복의 세가지 구성 요소
1. 문제를 더 작은 문제로 분할하는 과정(divide)
2. 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정(merge)
3. 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제(base case)
> 분할 정복을 적용하여 문제를 해결하기 위해서는 문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야 하며, 부분 문제의 답을 조합해 원래 문제의 답을
> 계산하는 것이 효율적인 방법이여야 한다.
# 예제 : 수열의 빠른 합과 행렬의 빠른 제곱
## 수열의 빠른 합
1부터 n까지의 합을 n개의 조각으로 나눈 뒤, 이들을 반으로 뚝 잘라 n/2개의 조각들로 만들어진 부분 문제 두개를 만든다.
### 코드
```java
import java.util.Scanner;
public class divide_conquer1 {
	
	//1 + 2 + ....... + n의 값을 반환
	static int fastSum(int n) {
		//기저 사례
		if(n == 1) return 1;
		//n이 홀수일 경우 짝수인 n-1까지의 합을 재귀 호출로 계산하고 n을 더해 답을 구함
		if(n % 2 == 1)
			return fastSum(n-1) + n;
		return 2 * fastSum(n/2) + (n/2) * (n/2);
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		System.out.println(fastSum(n));
	}
}
```
### 시간 복잡도
O(lgn)
## 행렬의 거듭제곱
A^m을 구하는 데 필요한 m개의 조각을 절반으로 나누어 계산
> A^m = A^m/2 * A^m/2
### 코드
```java
import java.util.Random;
import java.util.Scanner;

public class divide_conquer2 {

	static int[][] squareMatrix(int n){
		Random random = new Random();
		int M[][] = new int[n][n];
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < n;j++)
				M[i][j] = random.nextInt(2);
		}
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < n;j++)
				System.out.print(M[i][j]);
			System.out.println();
		}
		System.out.println();
		return M;
	}
	static int[][] identity(int n){
		int I[][] = new int[n][n];
		for(int i = 0; i < n;i++) {
			for(int j = 0 ; j < n; j++)
				I[i][i] = 1;
		}
		return I;
	}
	
	static int[][] powMatrix(int[][] A, int[][] B){
		int[][] result = new int[A.length][A.length];
		for(int i = 0; i < A.length;i++) {
			for(int j = 0; j < A.length; j++) 
				for(int k = 0; k < A.length;k++) {
					result[i][j] += (A[i][k] * B[k][j]);
			}
		}
		return result;
	}
	
	static int[][] pow(int[][] A, int m){
		//기저 사례 : A^0 = I
		if(m == 0) return identity(A.length);
		if(m%2 == 1) return powMatrix(pow(A, m-1) , A);
		//A^m = (A^(m/2)) * (A^(m/2))
		int[][] half = pow(A, m/2);
		return powMatrix(half, half);
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[][] ret = new int[n][n];
		ret = squareMatrix(n);
		ret = pow(ret, 2);
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < n; j++) {
				System.out.print(ret[i][j]);
			}
			System.out.println();
		}

	}

}
```
### 시간 복잡도
O(lgm)
# 예제 : 병합 정렬과 퀵 정렬
## 병합 정렬
주어진 수열을 가운데에서 쪼개 비슷한 크기의 수열 두 개로 만든 뒤 이들을 재귀 호출을 이용해 각각 정렬한 후 정렬된 배열을 하나로 합침으로써 정렬된 전체 수열을 얻는다.
### 과정
각 수열의 크기가 1이 될 때까지 절반씩 조깨 나간 뒤, 정렬된 부분 배열들을 합쳐 나간다.

주어진 배열을 나누는 과정은 O(1)만에 수행할 수 있다. 하지만 각각 나눠서 정렬한 배열들을 하나의 배열로 합치기 위한 병합 과정에서 O(n)의 시간이 걸린다.
### 시간 복잡도

## 퀵 정렬
배열을 단순하게 가운데에서 쪼개는 대신, 병합 과정이 필요 없도록 한쪽의 배열에 포함된 수가 다른 쪽 배열의 수보다 항상 작도록 배열을 분할
파티션이라는 단계가 추가 : 배열에 있는 수 중 임의의 '기준 수(pivot)'를 지정한 후 기준보다 작거나 같은 숫자를 왼쪽, 더 큰 숫자를 오른쪽으로 보내는 과정
### 과정
수열의 맨 처음에 있는 수를 기준으로 삼고, 이들보다 작은 수를 왼쪽, 큰 것을 오른쪽으로 가게끔 분해

주어진 배열을 분할하는 과정에서 O(n)의 시간이 걸린다. 병합하는 과정이 필요없다.

***
#### 참고 자료
구종만, [프로그래밍 대회에서 배우는 알고리즘 문제 해결전략], 인사이트
