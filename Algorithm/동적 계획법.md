# 동적 계획법
주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계싼하고, 이 답들로부터 원래 문제에 대한 답을 계산

어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용(Memoization)
## 이항 계수의 계산
이항계수 <img src= "https://user-images.githubusercontent.com/64197428/146712743-5b5fbfb8-f4b3-4f44-9daa-bd2b40f5e130.png" width="3%" height="3%"> 은 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이
골라내는 방법의 수를 나타낸다.

다음과 같은 점화식이 성립 <img src ="https://user-images.githubusercontent.com/64197428/146712873-3770c0d9-cf54-4ba1-83d7-213741a66941.png" width="18%" height="18%">
### 이항 계수 구현
#### 재귀 호출을 이용한 이항 계수의 계산
```java
int bino(int n, int r){
  //기저 사례: n=r (모든 원소를 다 고르는 경우) 혹은 r=0 (고를 원소가 없는 경우)
  if(r == 0 || n == r) return 1;
  return bino(n-1, r-1) + bino(n-1, r);
  }
```
> 같은 값을 두 번 이상 계산할 일이 빈번 --> 계산량의 낭비
#### 메모이제이션을 이용한 이항 계수의 계산
1. 각 n, r 조합에 대해 답을 저장하는 캐시 배열을 만들어서 각 입력에 대한 반환 값을 저장
2. 함수는 매번 호출될 떄마다 이 배열에 접근해 값이 저장되어 있는지를 확인한 뒤, 저장되어 있다면 이것을 즉시 반환
3. 저장되어 있지 않다면 직접 계산하여 배열에 써넣고 반환
```java
static int [][] cache = new int[30][30];	
static int bino2(int n, int r){
  //기저 사례
	if(r == 0 || n == r) return 1;
	//0이 아니라면 한 번 계산했던 값이니 곧장 반환
	if(cache[n][r] != 0)
	  return cache[n][r];
	//직접 계산한 뒤 배열에 저장
		return cache[n][r] = bino2(n-1, r-1) + bino2(n-1, r);
	}
```
## 메모이제이션 구현 패턴
- 항상 기저 사례를 제일 먼저 처리, 입력이 범위를 벗어난 경우 등을 기저 사례로 처리하면 유용하다.
- 함수의 반환값으로 쓰이지 않는 값으로 cache[]를 초기화 (반환 값이 항상 0 이상이라면 -1로 초기화)

## 예제 : 외발 뛰기
### 문제
![image](https://user-images.githubusercontent.com/64197428/146717907-49436c26-a535-41eb-b3b2-a9f9559aae9c.png)

땅따먹기를 하다 질린 재하와 영훈이는 땅따먹기의 변종인 새로운 게임을 하기로 했습니다. 이 게임은 그림과 같이 n*n 크기의 격자에 각 1부터 9 사이의 정수를 쓴 상태로 시작합니다. 각 차례인 사람은 맨 왼쪽 윗 칸에서 시작해 외발로 뛰어서 오른쪽 아래 칸으로 내려가야 합니다. 이 때 각 칸에 적혀 있는 숫자만큼 오른쪽이나 아래 칸으로 움직일 수 있으며, 중간에 게임판 밖으로 벗어나면 안 됩니다.

균형을 잃어서 다른 발로 서거나 넘어져도 게임에서 집니다만, 재하와 영훈이는 젊고 활기차기 때문에 외발로 뛰어다니는 것은 아무것도 아닙니다. 다만 걱정되는 것은 주어진 게임판에 시작점에서 끝점으로 가는 방법이 존재하지 않을 수도 있다는 것입니다. 예를 들어 그림 (a)의 게임판에서는 사각형으로 표시된 칸들을 통해 끝에 도달할 수 있지만, 숫자가 하나 바뀐 그림 (b)에서는 그럴 수가 없습니다.

게임판이 주어질 때 왼쪽 위의 시작점에서 오른쪽 아래의 시작점에 도달할 수 있는 방법이 있는지 확인하는 프로그램을 작성하세요.
### 입력
입력의 첫 줄에는 테스트 케이스의 수 C(C <= 50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 격자의 크기 n(2 <= n <= 100)이 주어지고, 그 후 n줄에 각 n개의 숫자로 왼쪽 위부터 각 칸에 쓰인 숫자들이 주어집니다. 오른쪽 아래 있는 끝 점 위치에는 0이 주어집니다.
### 출력
각 테스트 케이스마다 한 줄로, 시작점에서 끝 점으로 도달할 수 있을 경우 "YES"를, 아닐 경우 "NO"를 출력합니다. (따옴표 제외)

---
#### 참고 자료
구종만, [프로그래밍 대회에서 배우는 알고리즘 문제 해결전략], 인사이트
